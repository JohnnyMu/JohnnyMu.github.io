<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>踩坑日记：防盗链与x-tengine-error: denied by Referer ACL</title>
    <link href="/2020/03/28/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%EF%BC%9A%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8Ex-tengine-error-denied-by-Referer-ACL/"/>
    <url>/2020/03/28/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%EF%BC%9A%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8Ex-tengine-error-denied-by-Referer-ACL/</url>
    
    <content type="html"><![CDATA[<h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>之前写的知乎日报项目 <a href="https://johnnymu.github.io/2020/03/28/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A52-0/" target="_blank" rel="noopener">点击查看</a></p><p>在引用css文件时出现了bug，客户端显示出了403错误</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200328193008768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。</p></blockquote><p>我一开始以为是跨域限制导致的css文件无法加载，所以用代理服务器转发一下，设置上相应header字段就好，问题确实就解决了。</p><p>但是昨晚睡前一想，不对啊，css，图片等静态资源是不会被跨域限制的。于是我试了一下真正跨域限制的报错。果然不一样。<br><img src="https://img-blog.csdnimg.cn/20200328193649824.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>再试一下，将图片代理服务器中的取消跨域限制的代码注释掉</p><pre><code class="javascript">res.setHeader(&#39;Content-Type&#39;, contentType);// res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);res.end(body);</code></pre><p>重新打开网页，没有任何变化，完美运行。<br>说明之前的bug不是因为跨域产生的，那是因为什么呢。</p><p>打开控制台看一下请求这个css文件时的network，发现了问题<br><img src="https://img-blog.csdnimg.cn/20200328194744609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>在回复头字段里多了一个<code>x-tengine-error</code>，这是什么鬼，百度了一下，明白了，这是因为防盗链检测所出现的<code>error</code></p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><p>具体可以看这篇文章 <a href="https://www.jianshu.com/p/0a1338db6cab" target="_blank" rel="noopener">什么是防盗链</a></p><p>我总结一下</p><p>首先有一个问题，B站点作为一个商业网站，有很多自主版权的图片，自身展示用于商业目的。而A站点，希望在自己的网站上面也展示这些图片，直接使用：</p><pre><code class="javascript">&lt;img src=&quot;http://b.com/photo.jpg&quot;/&gt;</code></pre><p>这样，大量的客户端在访问A站点时，实际上消耗了B站点的流量，而A站点却从中达成商业目的。从而不劳而获。这样的A站点着实令B站点不快的。</p><p>这种行为又叫做盗链（那我岂不也是盗链者了QAQ）</p><p>如何解决这个问题呢？服务端利用了客户端的一个特性</p><p>客户端在加载非本站的资源时，会在头字段加上<code>Referer:</code>字段，用来告诉服务端，这个请求是来自哪里。<br>回头看一眼我们的network<br><img src="https://img-blog.csdnimg.cn/20200328200214620.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>确实有。</p><p>那我们可以推断，知乎服务器利用是否有referer字段来判断是否为盗链行为，如果是，那么返回403错误，与<code>x-tengine-error: denied by Referer ACL</code>字段。</p><p>而我们用代理服务器转发静态资源请求，代理服务器不会无端加上<code>referer</code>字段，相当于变相绕过了知乎服务器的盗链限制。</p><h2 id="出坑"><a href="#出坑" class="headerlink" title="出坑"></a>出坑</h2><p>验证一下，让代理服务器发送请求时带上<code>referer</code>字段，将request模块设置为调试模式</p><pre><code class="javascript">const imgServer = http.createServer((req, res) =&gt; {    const url = req.url.split(&#39;/img/&#39;)[1];    const options = {        url: url,        encoding: null,        headers: {            &quot;Referer&quot;: &quot;http://localhost:8080/&quot;,        }    };    function callback (error, response, body) {        if(error) console.log(error);        if (!error &amp;&amp; response.statusCode === 200) {            const contentType = response.headers[&#39;content-type&#39;];            res.setHeader(&#39;Content-Type&#39;, contentType);            // res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);            res.end(body);        }    }    request.get(options, callback);});</code></pre><p><img src="https://img-blog.csdnimg.cn/2020032820280853.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>看到终端输出，果然出现了同样的error</p><p><img src="https://img-blog.csdnimg.cn/20200328202537488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>说明我们的想法是对的，出坑。</p>]]></content>
    
    
    <categories>
      
      <category>踩坑日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>node</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue实战：知乎日报2.0</title>
    <link href="/2020/03/28/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A52-0/"/>
    <url>/2020/03/28/Vue%E5%AE%9E%E6%88%98%EF%BC%9A%E7%9F%A5%E4%B9%8E%E6%97%A5%E6%8A%A52-0/</url>
    
    <content type="html"><![CDATA[<p>之前跟着《Vue.js实战》写过这个小项目，因为书中的代码比较久远，许多接口、webpack配置都失效了，但这个项目还是很好玩的，最近整理了一下，本文的代码都是相对于原书代码的补充。<br>完整代码:<a href="https://github.com/JohnnyMu/zhihuDaily" target="_blank" rel="noopener">https://github.com/JohnnyMu/zhihuDaily</a></p><p><img src="https://img-blog.csdnimg.cn/20200326213059175.gif#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p>虽然最新的webpack已经是4.0版本。但与书中的webpack2大多能兼容，只有几个地方稍有变化</p><h3 id="vue-loader"><a href="#vue-loader" class="headerlink" title="vue-loader"></a>vue-loader</h3><p><a href="mailto:vue-loader@15.x">vue-loader@15.x</a> 版本相较之前需要增加一些配置</p><pre><code class="javascript">//webpack.config.jsconst VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);{...}    plugins:[new VueLoaderPlugin()]{...}</code></pre><h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>webpack4中建议使用mini-css-extract-plugin，而不是extract-text-webpack-plugin。</p><pre><code class="javascript">//webpack.config.jsconst MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);{...}{   test:/\.css$/,    use:[        {            loader: MiniCssExtractPlugin.loader        },        &#39;css-loader&#39;    ]}{...}new MiniCssExtractPlugin({            filename: &quot;[name].css&quot;,            chunkFilename: &quot;[id].css&quot;        })</code></pre><h3 id="遇到的一个坑"><a href="#遇到的一个坑" class="headerlink" title="遇到的一个坑"></a>遇到的一个坑</h3><p>因为这是一个单页应用，所以在写css的时候，我把他们全部写在app.vue文件中，这样在打包的时候，会自动的在打包后样式中加上属性选择器，就像这样</p><pre><code>.daily-item[data-v-186c01a3]:hover{    background: #e3e8ee;}</code></pre><p>然后坑来了，因为用的html-webpack-plugin自动生成html文件，而他的模板文件中的body、html元素不会自动生成相应的属性，打开控制台看一下Element<br><img src="https://img-blog.csdnimg.cn/20200326220121432.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>可以看到body，html元素均没有属性选择器，而生成的css文件有，这样，我们在app.vue中的有关<code>&lt;html&gt;&lt;body&gt;</code>的样式均无法生效。</p><p>解决：新建一个style.css文件，在main.js中引用，将body、html的样式写在里面，这样打包后的样式不会被加上属性选择器。</p><h2 id="热门栏目功能"><a href="#热门栏目功能" class="headerlink" title="热门栏目功能"></a>热门栏目功能</h2><p>因为书中的主题日报所用的api已经无效，看了一下这篇文章 <a href="https://blog.csdn.net/fanpeihua123/article/details/51210499" target="_blank" rel="noopener">日报 API 分析</a>，使用postman把里面的接口都试了一下，发现栏目的api可用，虽然是内容已经停止更新了，但作为练习的话，影响不大。<br><strong>首先建立一个section的代理服务器</strong>，用来转发数据，解决跨域限制</p><pre><code class="javascript">//proxy.jsconst http = require(&#39;http&#39;);const request = require(&#39;request&#39;);const hostname = &#39;127.0.0.1&#39;;const sectionPort= 8012;const sectionServer = http.createServer((req, res) =&gt; {    const url = &#39;http://news-at.zhihu.com/api/3&#39; + req.url;    const options = {        url: url    };    function callback (error, response, body) {        if (!error &amp;&amp; response.statusCode === 200) {            // 设置编码类型，否则中文会显示为乱码            res.setHeader(&#39;Content-Type&#39;, &#39;text/plain;charset=UTF-8&#39;);            // 设置所有域允许跨域            res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);            // 返回代理后的内容            res.end(body);        }    }    request.get(options, callback);});sectionServer.listen(sectionPort, hostname, () =&gt; {    console.log(`栏目代理运行在 http://${hostname}:${sectionPort}/`)});</code></pre><p><strong>增加相应的ajax模块</strong></p><pre><code class="javascript">//util.jsimport axios from &#39;axios&#39;;const Util = {    sectionPath:&#39;http://127.0.0.1:8012/&#39;};// Ajax 通用配置Util.ajaxSection = axios.create({    baseURL: Util.sectionPath});// 添加响应拦截器Util.ajaxStories.interceptors.response.use(res =&gt; {    return res.data;});export default Util;</code></pre><p>写上栏目的html结构，在data中加入我们需要维护的数据</p><pre><code class="javascript">//app.vue&lt;template&gt;&lt;div&gt;    &lt;div class=&quot;daily&quot;&gt;        &lt;div class=&quot;daily-menu&quot;&gt;        ...        &lt;div class=&quot;daily-menu-item&quot;            :class=&quot;{on:type===&#39;section&#39;}&quot;            @click=&quot;showSection = !showSection&quot;&gt;热门栏目&lt;/div&gt;            &lt;ul v-show=&quot;showSection&quot;&gt;                &lt;li v-for=&quot;item in sections&quot;&gt;                    &lt;a :class=&quot;{on: item.id === sectionId &amp;&amp; type === &#39;section&#39;}&quot;                    @click=&quot;handleToSection(item.id)&quot;&gt;{{ item.name}}&lt;/a&gt;                &lt;/li&gt;            &lt;/ul&gt;        &lt;/div&gt;    &lt;/div&gt;     &lt;div class=&quot;daily-list&quot; ref=&quot;list&quot;&gt;     ...     &lt;template v-if=&quot;type === &#39;section&#39;&quot;&gt;                &lt;item v-for=&quot;item in list&quot;                      :data=&quot;item&quot;                      :key=&quot;item.id&quot;                    @click.native=&quot;handleClick(item.id)&quot;&gt;&lt;/item&gt;            &lt;/template&gt;        &lt;/div&gt;         &lt;daily-article :id=&quot;articleId&quot; :type=&quot;this.type&quot;&gt;&lt;/daily-article&gt;    &lt;/div&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data(){            return {                sections:[],//保存栏目目录                showSection:false,//是否显示所有栏目                type:&#39;recommend&#39;,                sectionId:0,//保存栏目id                list:[],//保存访问栏目的所有文章                sectionTime:0,//本次请求的时间戳                           }        }    }        &lt;/script&gt;</code></pre><p>定义一个method，当点击栏目时，访问栏目api，获得栏目列表，并将数据写入data中</p><pre><code class="javascript">methods:{            getSections(){                $.ajaxSection.get(&#39;sections&#39;).then(res =&gt;{                    this.sections = res.data;                })            }        }</code></pre><p>当点击具体某个栏目时，中间栏要显示该栏目的文章列表，定义一个method，当调用这个method时，访问api，将数据写入data，DOM的改变让Vue去做</p><pre><code class="javascript">handleToSection(id){                this.type = &#39;section&#39;;                this.sectionId = id;                this.list = [];                $.ajaxSection.get(&#39;section/&#39;+id).then(res=&gt;{                    this.sectionTime = res.timestamp;                    this.list = res.stories;                })            }</code></pre><p>为中间栏添加scroll事件</p><pre><code class="javascript">mounted() {    const $list = this.$refs.list;    $list.addEventListener(&#39;scroll&#39;,()=&gt;{                if(this.isloading) return;                if($list.scrollTop + document.body.clientHeight &gt;= $list.scrollHeight-100){                    if(this.type === &#39;recommend&#39;) {                        this.dailyTime -=86400000;                        this.getRecommendList();                    }else{                        this.getSectionList()                    }                }            });}</code></pre><p>下拉中间栏到底，自动加载更多数据</p><pre><code class="javascript">getSectionList(){                this.isloading = true;                $.ajaxSection.get(&#39;section/&#39; +this.sectionId+`/before/${this.sectionTime}`).then(res=&gt;{                    this.sectionTime= res.timestamp;                    for (const value of res.stories){                        this.list.push(value);                    }                    this.isloading=false;                })            }</code></pre><h2 id="栏目文章详情组件"><a href="#栏目文章详情组件" class="headerlink" title="栏目文章详情组件"></a>栏目文章详情组件</h2><p>一开始只是把日报的组件拿来用，发现直接用v-html转换的页面太难看。<br><img src="https://img-blog.csdnimg.cn/20200327123440199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>正好栏目api提供了对应文章的知乎页面的url</p><pre><code>{    &quot;timestamp&quot;: 1463148001,    &quot;stories&quot;: [        {            &quot;image_hue&quot;: &quot;0x3779b3&quot;,            &quot;title&quot;: &quot;深夜惊奇 · 要穿内衣&quot;,            &quot;url&quot;: &quot;https://daily.zhihu.com/story/8387524&quot;,            &quot;date&quot;: &quot;20160601&quot;,            &quot;display_date&quot;: &quot;6 月 1 日&quot;,            &quot;images&quot;: [                &quot;http://pic3.zhimg.com/91125c9aebcab1c84f58ce4f8779551e.jpg&quot;            ],            &quot;id&quot;: 8387524        },</code></pre><p>可以看到上面的stories中url就是文章对应知乎页面了，我们用v-html直接显示<br><strong>增加一个stories代理服务器</strong>，与之前类似</p><pre><code class="javascript">//proxy.jsconst storiesServer = http.createServer((req, res) =&gt; {    const url = &#39;https://daily.zhihu.com/story&#39; + req.url;    const options = {        url: url    };    function callback (error, response, body) {        //......        }    }    request.get(options, callback);});storiesServer.listen(storiesPort, hostname, () =&gt; {    console.log(`栏目故事代理运行在 http://${hostname}:${storiesPort}/`)});</code></pre><p>相应的ajax模块</p><pre><code class="javascript">//util.jsimport axios from &#39;axios&#39;;const Util = {   //...    storiesPath:&#39;http://127.0.0.1:8013/&#39;};Util.ajaxStories = axios.create({    baseURL:Util.storiesPath})Util.ajaxStories.interceptors.response.use(res =&gt; {    return res.data;});</code></pre><h5 id="daily-article组件"><a href="#daily-article组件" class="headerlink" title="daily-article组件"></a>daily-article组件</h5><p>props中增加一个参数type，接受父组件的信息，现在显示哪一部分，使用watch监控id与type，当他们发生改变时，调用相应方法</p><pre><code class="javascript">//daily-article.vue&lt;template&gt;    &lt;div class=&quot;daily-article&quot;&gt;        &lt;div v-if=&quot;this.type === &#39;recommend&#39;&quot; class=&quot;daily-article-title&quot;&gt;{{ data.title }}&lt;/div&gt;        &lt;div v-if=&quot;this.type === &#39;recommend&#39;&quot; class=&quot;daily-article-content&quot; v-html=&quot;data.body&quot;&gt;&lt;/div&gt;        &lt;div v-if=&quot;this.type === &#39;section&#39;&quot; v-html=&quot;this.htmlData&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;daily-comments&quot; v-show=&quot;comments.length&quot;&gt;                         &lt;!--...--&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;{...}props:{     type:{                    type:String,                    default:&#39;recommend&#39;                }            },     data(){            return{                htmlData:&#39;&#39;                }        },        watch:{            type(val){//类型发生变化，清空数据                this.data={},                this.comments=[],                this.htmlData=&#39;&#39;            },            id(val){//文章id变化，更新文章数据                if (this.type===&#39;recommend&#39;&amp;&amp;val) {                    this.getArticle();                }else {                    this.getStores()                }            }        }</code></pre><pre><code class="javascript">getStores(){//获得html源码，将里面的图片换成代理地址              $.ajaxStories.get(`${this.id}`).then(res=&gt;{                  res =res.replace(/src=&quot;http/g,&#39;src=&quot;&#39; + $.imgPath+&#39;http&#39;);                  res =res.replace(/src=&quot;https/g,&#39;src=&quot;&#39; + $.imgPath + &#39;https&#39;);                   this.htmlData = res;                    this.getComments();              })            }</code></pre><p>本以为大功告成了，打开网页发现并没有显示文章，上来就是评论<br><img src="https://img-blog.csdnimg.cn/2020032712353950.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>打开控制台看到<br><img src="https://img-blog.csdnimg.cn/20200327123608340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>看起来好像是css文件被跨域限制了，无法引用。那就用之前图片的代理服务器转发一下就好了。<br><strong>tips：其实不是，具体请看 <a href="https://johnnymu.github.io/2020/03/28/%E8%B8%A9%E5%9D%91%E6%97%A5%E8%AE%B0%EF%BC%9A%E9%98%B2%E7%9B%97%E9%93%BE%E4%B8%8Ex-tengine-error-denied-by-Referer-ACL/" target="_blank" rel="noopener">踩坑日记：防盗链与x-tengine-error: denied by Referer ACL</a></strong></p><pre><code class="javascript">//daily-article.vuemethods:{            getStores(){              $.ajaxStories.get(`${this.id}`).then(res=&gt;{              res =res.replace(/href=&quot;http/g,&#39;href=&quot;&#39; + $.imgPath+&#39;http&#39;);              res =res.replace(/href=&quot;https/g,&#39;href=&quot;&#39; + $.imgPath + &#39;https&#39;);})            }</code></pre><p>再打开网页，确实没问题了，但是这个知乎app的提醒很烦，把它去掉。<br><img src="https://img-blog.csdnimg.cn/20200327124025380.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在html里找他的类名，在后面加上display：none</p><pre><code class="javascript">//daily-article.vuemethods:{            getStores(){              $.ajaxStories.get(`${this.id}`).then(res=&gt;{              res =res.replace(/ZhihuDailyOIABanner&quot;/,&#39;ZhihuDailyOIABanner&quot; style=&quot;display:none;&quot;&#39;)              })            }</code></pre><p>完工</p>]]></content>
    
    
    <categories>
      
      <category>前端工程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise理解与实现</title>
    <link href="/2020/03/28/Promise%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2020/03/28/Promise%E7%90%86%E8%A7%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="promise解决了什么问题"><a href="#promise解决了什么问题" class="headerlink" title="promise解决了什么问题"></a>promise解决了什么问题</h2><p>JavaScript是单线程的，所以我们要用一些异步编程方案来实现异步。<br>回调函数就是其中的一种方案，比如说在node中写读取一个文件，使用回调函数这是没有问题的。</p><pre><code class="javascript">fs.readFile(&#39;/etc/passwd&#39;, function (err, data) {  if (err) throw err;  console.log(data);});</code></pre><p>但如果新的需求是必须先读取A文件，才能读取B文件</p><pre><code class="javascript">fs.readFile(fileA, function (err, data) {    fs.readFile(fileB, function (err, data) {              //...          })});</code></pre><p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为”回调地狱”（callback hell）。<br>而<code>promise</code>就是为了解决这个问题而生的</p><h2 id="什么是promise"><a href="#什么是promise" class="headerlink" title="什么是promise"></a>什么是promise</h2><p>它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p><pre><code class="javascript">var readFile = require(&#39;fs-readfile-promise&#39;);readFile(fileA)//读取文件A.then(function(data){//如果读取成功则执行该函数，打印数据  console.log(data.toString());}).then(function(){//如果打印成功，则开始读取文件B  return readFile(fileB);}).then(function(data){//如果文件B读取成功，则打印文件B的数据  console.log(data.toString());}).catch(function(err) {//过程中发生任何错误则捕获，打印该错误  console.log(err);});</code></pre><p>上面代码中，我使用了 <code>fs-readfile-promise</code> 模块，它的作用就是返回一个 Promise 版本的 <code>readFile</code> 函数。Promise 提供 <code>then</code> 方法加载回调函数，<code>catch</code>方法捕捉执行过程中抛出的错误。看起来清爽多了<br>再来看一段伪代码</p><pre><code class="javascript">//传统写法（层层嵌套，可读性差）：step1(function (value1) {   step2(value1, function(value2) {     step3(value2, function(value3) {       step4(value3, function(value4) { // ... });     });   });});//Promises的写法（清晰舒服）：(new Promise(step1))  .then(step2)  .then(step3)  .catch(step4);</code></pre><p>promise对象充当异步操作与回调函数之间的中介。简单的说就是：每一个异步任务会立刻返回一个Promise对象。Promises对象有一个<code>then</code>方法，允许指定回调函数，在异步任务完成后调用。如果异步任务失败则使用<code>catch</code>捕捉。</p><h3 id="Promise-的状态"><a href="#Promise-的状态" class="headerlink" title="Promise 的状态"></a>Promise 的状态</h3><p>等待（<code>pending</code>）：初始状态。<br>已完成（<code>fulfilled</code>）：意味着操作成功完成。<br>已失败（<code>rejected</code>）：意味着操作失败。</p><p>Promise对象的状态只可能处于这三种之一，它的状态改变只可能是两种可能：从 Pending 变为 <code>fulfilled</code> 和从 <code>Pending</code> 变为 <code>Rejected</code>。一旦状态发生改变，就不会再变，这也是<code>Promise[承诺]</code>这个名字的由来。</p><h3 id="promise的使用"><a href="#promise的使用" class="headerlink" title="promise的使用"></a>promise的使用</h3><p>再来看一个简单的例子</p><pre><code class="javascript">function getNumber(num){  return new Promise(function(resolve,reject){//返回一个promise对象      if(num &gt; 5){        resolve(num)//如果数字大于5则，执行resolve      }else{        reject(&#39;数字太小&#39;)}//否则执行reject  })}function printData(data){    console.log(&#39;resolve&#39;);    console.log(data);  }function printError(data){    console.log(&#39;reject&#39;);    console.log(data);}getNumber(4).then(printData).catch(printError);//reject 4getNumber(6).then(printData).catch(printError);//resolve 6</code></pre><p>当<code>promise</code>执行了<code>resolve</code>语句（模拟异步操作执行成功），那么<code>promise</code>的状态就回变为<code>resolve</code>，可以使用<code>then</code>方法，调用传入的回调函数，而回调函数的参数就是<code>resolve</code>中返回的数据。<br>相反<br>promise执行了<code>reject</code>语句（模拟异步操作执行失败），那么promise的状态就回变为<code>reject</code>，可以使用<code>catch</code>方法，调用传入的回调函数，而回调函数的参数就是reject中返回的数据。</p><h3 id="promise的其他方法"><a href="#promise的其他方法" class="headerlink" title="promise的其他方法"></a>promise的其他方法</h3><h4 id="promise-all"><a href="#promise-all" class="headerlink" title="promise.all"></a>promise.all</h4><p><code>Promise.all(iterable)</code> 方法返回一个 <code>Promise</code> 实例，此实例在 <code>iterable</code> 参数内所有的 <code>promise</code> 都“<code>完成（resolved）</code>”或参数中不包含 <code>promise</code> 时回调<code>完成（resolve）</code>；如果参数中  <code>promise</code> 有一个<code>失败（rejected）</code>，此实例回调<code>失败（reject）</code>，失败原因的是第一个失败 <code>promise</code> 的结果。</p><p>将两个promise对象拼成一个数组传进<code>all</code>方法。看有没有失败，有一个失败的，则整个<code>all</code>方法产生的promise对象失败。</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve(&#39;hello&#39;);}, 1000);})const p2 = new Promise((resolve, reject) =&gt; {    resolve(1);  }) Promise.all([p1,p2]).then(//传入的是两个promise对象    result=&gt;console.log(result)  ).catch(    e=&gt;console.log(e)          )// Array(2) [&quot;hello&quot;, 1]</code></pre><p>将因为两个<code>promise</code>对象的状态都是已完成，所以返回的是数组，包含着两个<code>promise</code>的回调参数</p><p>在看另外一个例子</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; {        resolve(&#39;第一个任务&#39;);})const p2 = new Promise((resolve,reject) =&gt;{    setTimeout(() =&gt; {        reject(&#39;第二个任务&#39;)    }, 1000);})const p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        reject(&#39;第三个任务&#39;);        }, 500);  })Promise.all([p1,p2,p3]).then(    result=&gt;console.log(result)  ).catch(    e=&gt;console.log(e)          )//第三个任务</code></pre><p>执行结果打印的是第三个任务，细品这段代码就能明白<code>Promise.all</code>干的是啥了</p><h4 id="promise-all的实现"><a href="#promise-all的实现" class="headerlink" title="promise.all的实现"></a><code>promise.all</code>的实现</h4><pre><code class="javascript">/** 仅考虑 promises 传入的是数组的情况时 */Promise.all = function (promise) {    let promises = Array.from(promise)//将iterator转换为数组    return new Promise((resolve, reject) =&gt; {        if (promises.length === 0) {//如果数组长度为0则返回空数组            resolve([]);        } else {            let result = [];//存放已成功的异步操作            let index = 0;//记录已成功的操作数            for (let i = 0;  i &lt; promises.length; i++ ) {                Promise.resolve(promises[i])//执行每一个promise                    .then(data =&gt; {                        result[i] = data;                        if (++index === promises.length) {                        //所有的 promises 状态都是 fulfilled，promise.all返回的实例才变成 fulfilled 态                            resolve(result);                    }                }, err =&gt; {                    reject(err);                    return;                });            }        }    });}</code></pre><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a><code>Promise.race()</code></h4><p><code>Promise.race(iterable)</code> 方法返回一个 <code>promise</code>，一旦迭代器中的某个<code>promise</code>解决或拒绝，返回的 <code>promise</code>就会解决或拒绝<br>举个例子</p><pre><code class="javascript">const p1 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {         resolve(&#39;第一个任务&#39;);    }, 200);})const p2 = new Promise((resolve,reject) =&gt;{    setTimeout(() =&gt; {        reject(&#39;第二个任务&#39;)    }, 1000);})const p3 = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; {        resolve(&#39;第三个任务&#39;);        }, 500);  })Promise.all([p1,p2,p3]).then(    result=&gt;console.log(result)  ).catch(    e=&gt;console.log(e)          )//第一个任务</code></pre><p>只要其中一个实例先改变状态，状态就跟着改变将率先改变的<code>Promise</code>返回值传递给回调函数，大白话：看谁快</p><h4 id="Promise-race-实现"><a href="#Promise-race-实现" class="headerlink" title="Promise.race()实现"></a><code>Promise.race()</code>实现</h4><pre><code class="javascript">var race = function(promise) {    let promises = Array.from(promise)    return new Promise(function(resolve, reject) {        for (var i = 0; i &lt; promises.length; i++) {                Promise.resolve(promises[i]).then(data =&gt; {                resolve(data);                    }, err =&gt; {                      return reject(err)        })      }    })  }</code></pre><h4 id="Promise-resolve-和Promise-reject"><a href="#Promise-resolve-和Promise-reject" class="headerlink" title="Promise.resolve()和Promise.reject()"></a><code>Promise.resolve()</code>和<code>Promise.reject()</code></h4><pre><code class="javascript">// Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejectedconst p = Promise.reject(&#39;出错了&#39;);// 等同于const p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;))p.then(null, function (s) {  console.log(s)      // 出错了});</code></pre><pre><code class="javascript">Promise.resolve(&#39;foo&#39;)// 等价于new Promise(resolve =&gt; resolve(&#39;foo&#39;))</code></pre><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023024413276544</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html</a></li><li><a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener">https://es6.ruanyifeng.com/#docs/promise</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>异步编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同源限制理解与解决</title>
    <link href="/2020/03/28/%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6%E7%90%86%E8%A7%A3%E4%B8%8E%E8%A7%A3%E5%86%B3/"/>
    <url>/2020/03/28/%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6%E7%90%86%E8%A7%A3%E4%B8%8E%E8%A7%A3%E5%86%B3/</url>
    
    <content type="html"><![CDATA[<p>同源策略是浏览器对JavaScript代码能够操作哪些web内容的一条完整的安全限制。</p><h2 id="什么是同源"><a href="#什么是同源" class="headerlink" title="什么是同源"></a>什么是同源</h2><p>URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。<br>下表给出了相对<code>http://store.company.com/dir/page.html</code>同源检测的示例:</p><table><thead><tr><th>URL</th><th>结果</th><th>原因</th></tr></thead><tbody><tr><td><a href="http://store.company.com/dir2/other.html" target="_blank" rel="noopener">http://store.company.com/dir2/other.html</a></td><td>成功</td><td>只有路径不同</td></tr><tr><td><a href="http://store.company.com/dir/inner/another.html" target="_blank" rel="noopener">http://store.company.com/dir/inner/another.html</a></td><td>成功</td><td>只有路径不同</td></tr><tr><td><a href="https://store.company.com/secure.html" target="_blank" rel="noopener">https://store.company.com/secure.html</a></td><td>失败</td><td>不同协议 ( https和http )</td></tr><tr><td><a href="http://store.company.com:81/dir/etc.html" target="_blank" rel="noopener">http://store.company.com:81/dir/etc.html</a></td><td>失败</td><td>不同端口 ( http:// 80是默认的)</td></tr><tr><td><a href="http://news.company.com/dir/other.html" target="_blank" rel="noopener">http://news.company.com/dir/other.html</a></td><td>失败</td><td>不同域名 ( news和store )</td></tr></tbody></table><h2 id="同源策略阻止什么"><a href="#同源策略阻止什么" class="headerlink" title="同源策略阻止什么"></a>同源策略阻止什么</h2><p>同源策略最初由网景公司添加到浏览器，当前所有的浏览器都支持此功能。</p><p>初始的功能是为了限制非同域网页之间cookie的访问，例如a.html页面无法访问非同域的b.html页面的cookie。</p><p> 功能是为了保护网站信息安全，比如，一个电脑可以访问很多网站，总不能此网站可以读取另一个网站的信息，尤其是涉及到重要信息，比如用户名和密码。</p><p>随着浏览器功能的增强，同源策略由最初限制cookie的访问，发展到限制多种本地信息:</p><ul><li><p>Cookie、LocalStorage 和 IndexedDB访问限制。<br>a.html的脚本无法访问b.html页面下的上述种类浏览器缓存，为了防止恶意网站通过js获取用户其他网站的cookie。</p></li><li><p>DOM获取限制。<br>在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;link&gt;</code>等含有<code>src</code>属性的标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。</p><p>  如果没有这一条，恶意网站可以通过iframe打开银行页面，可以获取dom就相当于可以获取整个银行页面的信息。</p></li><li><p>无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应)，本质上跟上一条是一样的</p><blockquote><p>假设有一个黑客叫做小黑，他从网上抓取了一堆美女图做了一个网站，每日访问量爆表。<br>为了维护网站运行，小黑挂了一张收款码，觉得网站不错的可以适当资助一点，可是无奈伸手党太多，小黑的网站入不敷出。<br>于是他非常生气的在网页中写了一段js代码，使用ajax向淘宝发起登陆请求，因为很多数人都访问过淘宝，所以电脑中存有淘宝的cookie，不需要输入账号密码直接就自动登录了，然后小黑在ajax回调函数中解析了淘宝返回的数据，得到了很多人的隐私信息，转手一卖，小黑的网站终于盈利了。<br>如果跨域也可以发送AJAX请求的话，小黑就真的获取到了用户的隐私并成功获利了！！！</p></blockquote></li></ul><h2 id="同源策略允许什么"><a href="#同源策略允许什么" class="headerlink" title="同源策略允许什么"></a>同源策略允许什么</h2><ul><li><p>可以加载其他静态资源如javascript、css、图片等</p></li><li><p>页面中的<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;ifram&gt;</code>、<code>&lt;link&gt;</code>等标签、重定向以及表单提交是不会受到同源策略限制的，比如在网站<code>www.foo.com</code>下提交一个表单到<code>www.bar.com</code>是完全可以的。</p></li><li><p>跨域资源嵌入是允许的。</p><blockquote><p>脚本本身的来源和同源策略并不相关，相关的是脚本所嵌入的文档的来源，理解这一点很重要。例如、假设一个来自主机A的脚本被包含到（使用<code>&lt;script&gt;</code>标记的src属性）宿主B的一个web页面中。这个脚本的来源就是主机B而不是A，并且可以完整的访问包含它的文档内容。如果脚本打开一个新的窗口载入来自主机B的另一个文档，脚本对这个文档的内容也完全具有访问权限。但是，如果脚本打开第三个窗口并载入一个来自主机C吃文档（或者是主机A），同源策略会发挥作用，阻止脚本访问这个文档。</p></blockquote></li></ul><h2 id="如何跨域"><a href="#如何跨域" class="headerlink" title="如何跨域"></a>如何跨域</h2><h3 id="1-iframe跨域"><a href="#1-iframe跨域" class="headerlink" title="1.iframe跨域"></a>1.iframe跨域</h3><p><a href="https://www.cnblogs.com/happy-8090/p/11570998.html" target="_blank" rel="noopener">参考happy哥</a></p><ul><li><p><code>document.domain</code>跨域</p><p>  <strong>此方案仅限主域相同，子域不同的跨域应用场景。</strong></p><p>  同源策略会给那些使用多个子域的大站点带来一些问题。如，来自<code>home.example.com</code>的文档里脚本想要合法的读取从<code>developer.example.com</code>上的文档的属性。为了支持这种类型的多域名站点，可以使用Document对象的<code>domain</code>属性。在默认情况下，属性<code>domain</code>存放的是载入文档的服务器的主机名。可以设置这一个属性，不过字符串必须具有有效的域前缀或他本身。因此，如果一个<code>domain</code>属性的初始值是字符串<code>home.example.com</code>，就可以把它设置为<code>example.com</code>。但是不能设置为<code>home.example</code>或者<code>ample.com</code>。另外<code>domain</code>值中必须有一个.，不能把它设置为<code>com</code>或其他顶级域名。如果两个窗口（或窗体）包含的脚本把domain设置成了相同的值，那么这两个窗口就不会再受同源策略的约束。<br>  在<code>home.example.com</code>和<code>developer.example.com</code>的文档同时使用脚本设置</p></li></ul><pre><code>```javascriptdocument.domain = &#39;example.com&#39;```实现跨域，**cookie**也可以用这种方法实现跨域</code></pre><ul><li><p><code>location.hash</code> 跨域<br>当主域不同时，可以使用此方法<br>在url中，<code>http://www.baidu.com#helloword</code>的<code>#helloworad</code>就是<code>location.hash</code>，改变hash值不会导致页面刷新，所以可以利用hash值来进行数据的传递，当然数据量是有限的。<br>父窗口可以把信息，写入子窗口的<code>location.hash</code>。</p><pre><code class="javascript">  var src = originURL + &#39;#&#39; + data;  document.getElementById(&#39;myIFrame&#39;).src = src;</code></pre><p>  子窗口通过监听<code>hashchange</code>事件得到通知。</p></li></ul><pre><code>```javascriptwindow.onhashchange = checkMessage;function checkMessage() {  var message = window.location.hash;  // ...}```同样的，子窗口也可以改变父窗口的片段标识符。```javascriptparent.location.href= target + &quot;#&quot; + hash;```</code></pre><ul><li><p><code>window.name</code>跨域<br><code>window.name</code>（一般在js代码里出现）的值不是一个普通的全局变量，而是当前窗口的名字，要注意的是每个iframe都有包裹它的window，而这个window是top window的子窗口，而它自然也有window.name的属性，window.name属性的神奇之处在于name值在不同的页面（甚至不同域名）加载后依旧存在（如果没有修改则值不会变化），并且可以支持非常长的name值（2MB）<br>举个简单的例子：你在某个页面的控制台输入：</p><pre><code class="javascript">  window.name = &quot;hello world&quot;  window.location = &quot;http://www.baidu.com&quot;</code></pre><p>  页面跳转到了百度首页<br>  <img src="https://img-blog.csdnimg.cn/20200216152224507.png" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>  但是<code>window.name</code>却被保存下来了，还是<code>hello world</code>。</p><blockquote><p>这种方法的优点是，window.name容量很大，可以放置非常长的字符串；缺点是必须监听子窗口window.name属性的变化，影响网页性能。</p></blockquote></li><li><p>跨文本消息 <code>postMessage</code><br><code>postMessage</code> 是 HTML5 新增加的一项功能，跨文档消息传输(Cross Document Messaging)，目前：Chrome 2.0+、Internet Explorer 8.0+, Firefox 3.0+, Opera 9.6+, 和 Safari 4.0+ 都支持这项功能。<br>举例来说，父窗口<code>http://aaa.com</code>向子窗口<code>http://bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p><pre><code class="javascript">  var popup = window.open(&#39;http://bbb.com&#39;, &#39;title&#39;);  popup.postMessage(&#39;Hello World!&#39;, &#39;http://bbb.com&#39;);</code></pre><p>  子窗口向父窗口发送消息的写法类似。</p></li></ul><pre><code>```javascriptwindow.opener.postMessage(&#39;Nice to see you&#39;, &#39;http://aaa.com&#39;);```父窗口和子窗口都可以通过message事件，监听对方的消息。```javascriptwindow.addEventListener(&#39;message&#39;, function(e) {console.log(e.data);},false);```message事件的事件对象event，提供以下三个属性。```event.source：发送消息的窗口event.origin: 消息发向的网址event.data: 消息内容```</code></pre><h3 id="2-Ajax跨域"><a href="#2-Ajax跨域" class="headerlink" title="2. Ajax跨域"></a>2. Ajax跨域</h3><ul><li><p>Jsonp<br>JSONP是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，老式浏览器全部支持，服务器改造非常小。</p><p>  它的基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>  首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨源网址发出请求。</p><pre><code class="javascript">  function addScriptTag(src) {//定义添加script标签函数  var script = document.createElement(&#39;script&#39;);  script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);  script.src = src;  document.body.appendChild(script);  }  window.onload = function () {//当文档加载完成时，发送Jsonp请求    addScriptTag(&#39;http://example.com/ip?code=123&amp;callback=foo&#39;);    //url中包含code需要的数据，与需要的回调函数callback  }  function foo(data) {//回调函数，当数据返回时，调用    console.log(&#39;Your public IP address is: &#39; + data.ip);  };</code></pre><p>  上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器example.com发出请求。注意，该请求的查询字符串有一个callback参数，用来指定回调函数的名字，这对于JSONP是必需的。<br>  服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p><pre><code class="javascript">  foo({      &quot;ip&quot;: &quot;8.8.8.8&quot;  });</code></pre><p>  由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。</p></li><li><p>CORS跨域资源共享<br>CORS的主要工作在后端，是HTML5规范定义的如何跨域访问资源。<br>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。<br>用一个图来表示就是：<br><img src="https://img-blog.csdnimg.cn/20200216161317768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p><p>  可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p><p>  上面这种跨域请求，称之为“简单请求”。简单请求包括GET、HEAD和POST（POST的Content-Type类型 仅限<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>和<code>text/plain</code>），并且不能出现任何自定义头（例如，X-Custom: 12345），通常能满足90%的需求。</p><p>  无论你是否需要用JavaScript通过CORS跨域请求资源，你都要了解CORS的原理。最新的浏览器全面支持HTML5。在引用外域资源时，除了JavaScript和CSS外，都要验证CORS。例如，当你引用了某个第三方CDN上的字体文件时：</p><pre><code class="javascript">  /* CSS */  @font-face {    font-family: &#39;FontAwesome&#39;;    src: url(&#39;http://cdn.com/fonts/fontawesome.ttf&#39;) format(&#39;truetype&#39;);  }</code></pre><p>  如果该CDN服务商未正确设置<code>Access-Control-Allow-Origin</code>，那么浏览器无法加载字体资源。</p><p>  对于<code>PUT</code>、<code>DELETE</code>以及其他类型如<code>application/json</code>的POST请求，在发送AJAX请求之前，浏览器会先发送一个OPTIONS请求（称为preflighted请求）到这个URL上，询问目标服务器是否接受：</p><pre><code>  OPTIONS /path/to/resource HTTP/1.1  Host: bar.com  Origin: http://my.com  Access-Control-Request-Method: POST</code></pre><p>  服务器必须响应并明确指出允许的Method：</p><pre><code>  HTTP/1.1 200 OK  Access-Control-Allow-Origin: http://my.com  Access-Control-Allow-Methods: POST, GET, PUT, OPTIONS  Access-Control-Max-Age: 86400</code></pre><p>  浏览器确认服务器响应的<code>Access-Control-Allow-Methods</code>头确实包含将要发送的AJAX请求的Method，才会继续发送AJAX，否则，抛出一个错误。</p><p>  由于以POST、PUT方式传送JSON格式的数据在REST中很常见，所以要跨域正确处理POST和PUT请求，服务器端必须正确响应OPTIONS请求。</p><h3 id="3-cookie跨域"><a href="#3-cookie跨域" class="headerlink" title="3. cookie跨域"></a>3. cookie跨域</h3></li><li><p>document.domain跨域，与iframe类似</p></li><li><p>Jsonp跨域</p></li><li><p>Ajax+cors跨域<br>默认情况下，标准的跨域请求是不会发送不同源的cookie的<br>在ajax请求中加入以下字段，请求为跨域类型时，在请求中协带cookie</p><pre><code class="javascript">  var xhr = new XMLHttpRequest();  xhr.withCredentials = true;</code></pre><p>  同时为了安全，标准里不允许 <code>Access-Control-Allow-Origin: *</code>，<code>*</code>必须指定明确的、与请求网页一致的域名。</p><h3 id="4-LocalStorage跨域"><a href="#4-LocalStorage跨域" class="headerlink" title="4. LocalStorage跨域"></a>4. LocalStorage跨域</h3></li><li><p>postMessage</p></li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/hansexploration/article/details/80314948" target="_blank" rel="noopener">https://blog.csdn.net/hansexploration/article/details/80314948</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a><br><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1022910821149312/1023022332902400</a><br><a href="https://blog.csdn.net/shuidinaozhongyan/article/details/78155310" target="_blank" rel="noopener">https://blog.csdn.net/shuidinaozhongyan/article/details/78155310</a><br><a href="https://blog.csdn.net/chou_out_man/article/details/80664413" target="_blank" rel="noopener">https://blog.csdn.net/chou_out_man/article/details/80664413</a><br><a href="https://blog.csdn.net/itcats_cn/article/details/82318092" target="_blank" rel="noopener">https://blog.csdn.net/itcats_cn/article/details/82318092</a><br><a href="https://www.cnblogs.com/happy-8090/p/11570998.html" target="_blank" rel="noopener">https://www.cnblogs.com/happy-8090/p/11570998.html</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>http</tag>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript学习笔记二</title>
    <link href="/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<p>数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中的位置，以数字表示，称为索引。<br>JavaScript数组是JavaScript对象的特殊形式，数组索引实际上和碰巧是整数的属性名差不多。通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多<br>JavaScript数组可以包含任意数据类型</p><h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><ol><li>使用数组字面量<code>[]</code><br>JavaScript数组可以包含任意数据类型<pre><code class="javascript"> var arr = [1,2,&#39;hello&#39;,null,undefined,true,{&#39;hei&#39;:&#39;黑&#39;},[1,2]]; arr.length;//8</code></pre> 如果直接省略数组中某个值将被赋予<code>undefined</code>值</li></ol><pre><code>```javascriptvar count=[1,,3];count[1];//undefinedvar undefs = [,,];//数组有个两个元素都是undefined,索引已经定义```因为数组字面量语法允许有可选的结尾的逗号，故`[,,]`只有两个元素而非三个</code></pre><ol start="2"><li><p>调用构造函数<code>Array()</code></p><pre><code class="javascript"> var a = new Array()//空数组，等同于数组字面量[]. var b = new Array(10)//创建指定长度的数组，此时数组中没有元素，甚至索引属性‘0’、‘1’都未定义 b.length();//10 0 in b;//false var c = new Array(1,2,&#39;hello&#39;,null,undefined,true,{&#39;hei&#39;:&#39;黑&#39;},[1,2]) //创建一数组，构造函数的参数将会成为新数组的元素，使用个数组字面量比使用构造函数要简单</code></pre><h2 id="数组的读写"><a href="#数组的读写" class="headerlink" title="数组的读写"></a>数组的读写</h2><p>使用<code>[]</code>操作符来访问修改数组中的一个元素</p></li></ol><pre><code class="javascript">arr[0];//读取下标为0的元素，1arr[8] = &#39;end&#39;;//在下标为8的地方写入数据arr.length;//9arr[-1.23] = true;//这将创建一个名为‘-1.23’的属性arr[&#39;1000&#39;] = 0;arr.length;//9,不变arr[1.000];//与a[1]相等</code></pre><h2 id="数组的长度"><a href="#数组的长度" class="headerlink" title="数组的长度"></a>数组的长度</h2><p>每个数组有一个<code>length</code>属性，就是这个属性使其区别于其他常规的JavaScript对象。</p><pre><code class="javascript">arr.length;//9arr.length = 3;//现在arr为[1,2,&#39;hello&#39;]arr.length = 0;//删除所有元素，a为[];arr.length = 5;//长度为5，没有元素，就像new Array(5)</code></pre><h2 id="数组元素的添加和删除"><a href="#数组元素的添加和删除" class="headerlink" title="数组元素的添加和删除"></a>数组元素的添加和删除</h2><ul><li>添加</li></ul><ol><li><p>添加数组元素最简单的方法：为新索引赋值：</p><pre><code class="javascript"> a = []   //空数组 a[0] = 1;//[1] a[2] = 2;//[1,,2]</code></pre></li><li><p>使用<code>push()</code>和<code>pop()</code></p><pre><code class="javascript"> a = [0]; a.push(1);//向末尾添加一个元素。 [0,1] a.unshift(0);//向开头添加一个元素。[0,0,1]</code></pre></li></ol><ul><li>删除</li></ul><ol><li><p><code>delete()</code>,类似于赋值undefined，不会影响数组长度</p><pre><code class="javascript"> a =[1,2,3]; delete a[1]; 1 in a;//false a.length;//3</code></pre></li><li><p><code>pop()</code> <code>shift()</code></p><pre><code class="javascript"> a = [1,2,3]; a.shift();//移除开头元素,[2,3] a.pop();//移除末尾元素，[2]</code></pre><p>最后一个可删除，可添加的方法<code>splice()</code>,详细内容往下看</p><h2 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h2></li><li><p><code>for</code>循环<br>最常用</p></li><li><p><code>for in</code>循环，遍历的是索引<br>for in可以遍历对象，也可遍历数组，但遍历数组的时候有些问题</p><blockquote><p>1.index索引为字符串型数字，不能直接进行几何运算<br>2.遍历顺序有可能不是按照实际数组的内部顺序<br>3.使用for in会遍历数组所有的可枚举属性，包括原型。所以for in更适合遍历对象，不要使用for in遍历数组</p></blockquote></li><li><p><code>for of</code>循环（ES6），遍历的是元素。</p><pre><code class="javascript"> Array.prototype.method=function(){ 　　console.log(this.length); } var myArray=[1,2,4,5,6,7] myArray.name=&quot;数组&quot;; for (var value of myArray) {   console.log(value); } //1 2 4 5 6 7</code></pre><blockquote><pre><code>记住，for in遍历的是数组的索引（即键名），而for of遍历的是数组元素值。</code></pre><p>for of遍历的只是数组内的元素，而不包括数组的原型属性method和索引name</p></blockquote></li><li><p><code>forEach()</code> (ES5)</p><pre><code class="javascript"> var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]; a.forEach(function (element) {     console.log(element); });//A,B,C</code></pre><p> forEach()方法无法再所有元素都传递给调用函数之前终止遍历。也就是说，没有像for循环中使用的相应的break语句。如果要提前终止，必须把forEach()方法放在一个try中，并抛出一个异常。</p><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2></li></ol><ul><li><p><code>Array.concat(item...)</code><br>该方法产生一个新数组，它包含一份array的赋值并把一个或多个item附加在它后面</p><pre><code class="javascript">  var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];  var b = [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;];  var c = a.concat(b,true);  //[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;,&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,true]</code></pre></li><li><p><code>Array.join(separator)</code><br>把一个array构造成一个字符串。他把array中的每个元素使用<code>separator</code>连接起来，构成一个字符串，默认的<code>separator</code> 是<code>,</code>，无间隔连接使用空字符串<code>&#39;&#39;</code></p><pre><code class="javascript">  var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];  var c = a.join(&#39;&#39;);//&#39;ABC&#39;</code></pre></li><li><p><code>Array.reverse()</code><br>翻转array里的元素的排序，并返回array本身：</p><pre><code class="javascript">  var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];  a.reverse();//a和b都是[&#39;C&#39;,&#39;B&#39;,&#39;A&#39;]</code></pre></li><li><p><code>Array.slice(start,end)</code><br>对array中的一段做浅复制。首先复制<code>array[start]</code>,一直复制到<code>array[end]</code>为止。<code>end</code>参数是可选的，默认是该数组的长度<code>array.length</code>。</p><pre><code class="javascript">  var a = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;];  b = a.slice(0,1);//[&#39;A&#39;]  c = a.slice(1);//[&#39;B&#39;,&#39;C&#39;]  d = a.slice(4);//[]</code></pre></li><li><p><code>Array.sort(comparefn)</code><br><code>sort</code>方法对array中的内容进行排序。他不能正确的给一组数字排序：</p><pre><code class="javascript">  var a = [4,8,15,16,23,42];  a.sort();//Array(6) [15, 16, 23, 4, 42, 8]</code></pre><p>  JavaScript的默认比较函数把要排序的元素都视为字符串。，比较数字的时候，会把他们转换为字符串，于是得到了一个错误结果。<br>  幸运的是可以使用自己的比较函数，你的比较函数接受两个参数，并且如果相等返回0，如果第一个参数在前，则返回一个负数，如果第二个参数应在前，则返回一个正数。</p><pre><code class="javascript">  var a = [4,8,15,16,23,42];  a.sort(function(a,b){      return a-b  });//Array(6) [4, 8, 15, 16, 23, 42]</code></pre></li><li><p><code>array.splice (start,deleteCount,item...)</code><br><code>splice</code>方法从array中移除一个或者多个元素，并使用新的item替换他们。参数<code>start</code>是从数组array中移除元素的开始位置。参数<code>deleteCount</code>是要移除的元素个数。如果有额外参数那些<code>item</code>会插入到被移除元素的位置上</p><pre><code class="javascript">  var arr = [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;, &#39;Oracle&#39;];  // 从索引2开始删除3个元素,然后再添加两个元素:  arr.splice(2, 3, &#39;Google&#39;, &#39;Facebook&#39;); // 返回删除的元素 [&#39;Yahoo&#39;, &#39;AOL&#39;, &#39;Excite&#39;]  arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]  // 只删除,不添加:  arr.splice(2, 2); // [&#39;Google&#39;, &#39;Facebook&#39;]  arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Oracle&#39;]  // 只添加,不删除:  arr.splice(2, 0, &#39;Google&#39;, &#39;Facebook&#39;); // 返回[],因为没有删除任何元素  arr; // [&#39;Microsoft&#39;, &#39;Apple&#39;, &#39;Google&#39;, &#39;Facebook&#39;, &#39;Oracle&#39;]</code></pre></li><li><p><code>map()</code>(ES5)<br>举例说明，比如我们有一个函数f(x)=x^2^，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下:<br><img src="https://img-blog.csdnimg.cn/20200214165103406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2pvaG5ueV9tdQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="map"></p><pre><code class="javascript">  function pow(x) {      return x * x;  }  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9];  var results = arr.map(pow); // [1, 4, 9, 16, 25, 36, 49, 64, 81]  console.log(results);</code></pre></li><li><p><code>filter()</code><br>它用于把Array的某些元素过滤掉，然后返回剩下的元素。<br>和<code>map()</code>类似，Array的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。</p><pre><code class="javascript">  //删除偶数，保留奇数  var arr = [1, 2, 4, 5, 6, 9, 10, 15];  var r = arr.filter(function (x) {      return x % 2 !== 0;  });  r; // [1, 5, 9, 15]</code></pre><p>  <code>filter()</code>接收的回调函数，其实可以有多个参数。通常我们仅使用第一个参数，表示Array的某个元素。回调函数还可以接收另外两个参数，表示元素的位置和数组本身：</p></li></ul><pre><code>```javascript//去处Array的重复元素var r,arr = [&#39;apple&#39;, &#39;strawberry&#39;, &#39;banana&#39;,     &#39;pear&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;orange&#39;, &#39;strawberry&#39;];r = arr.filter(function (element, index, self) {    return self.indexOf(element) === index;});```</code></pre><ul><li><p><code>every()</code>与<code>some()</code><br><code>every()</code>方法像是数学中的量词 $\forall$：当且仅当对数组中的所有元素调用判定函数都返回<code>true</code>，他才返回<code>true</code></p><pre><code class="javascript">  var arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];  console.log(arr.every(function (s) {      return s.length &gt; 0;  })); // true, 因为每个元素都满足s.length&gt;0</code></pre><p>  <code>some()</code>方法则像数学中的量词 $\exists$：当数组中至少有一个元素调用判定函数返回<code>true</code>，他就返回<code>true</code>，否则返回<code>false</code></p></li></ul><pre><code>```javascriptvar arr = [&#39;Apple&#39;, &#39;pear&#39;, &#39;orange&#39;];    console.log(arr.every(function (s) {        return s.length &lt;5;    })); // true, 因为存在&#39;pear&#39;长度小于5```</code></pre><ul><li><p><code>reduce()</code>和<code>reduceRight()</code><br>Array的<code>reduce()</code>把一个函数作用在这个Array的<code>[x1, x2, x3...]</code>上，这个函数必须接收两个参数，<code>reduce()</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><pre><code>  [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4)</code></pre><pre><code class="javascript">  //用reduce求和  var arr = [1, 3, 5, 7, 9];  arr.reduce(function (x, y) {      return x + y;  }); // 25</code></pre><p>  <code>reduceRight()</code>的原理相同，只是方向相反</p></li><li><p><code>find(function(currentValue, index, arr))</code>（ES6）、<code>findIndex(function(currentValue, index, arr))</code>（ES6）、<code>indexOf(item,start)</code>、<code>lastIndexOf(item,start)</code>和<code>includes(searchElement, fromIndex)</code><br><code>find()</code> 方法返回数组中满足提供的测试函数的第一个元素的值。<code>currentValue</code>必选参数，当前元素。<code>index</code>可选参数，当前元素索引。</p><pre><code class="javascript">  var ages = [3, 10, 18, 20];  function checkAdult(age) {      return age &gt;= 18;  }  var value = ages.find(checkAdult);  //18</code></pre><p>  <code>findIndex()</code>方法返回数组中满足提供的测试函数的第一个元素的索引。否则返回<code>-1</code></p></li></ul><pre><code>```javascriptvar ages = [3, 10, 18, 20];function checkAdult(age) {        return age &gt;= 18;    }var value = ages.findIndex(checkAdult);    //2````indexOf()`方法返回在数组中可以找到给定元素的第一个索引，如果不存在，则返回`-1`，`item`是要找的元素，`start`是开始位置（可选，默认`0`）```javascriptvar fruits=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];var a = fruits.indexOf(&quot;Apple&quot;,4);//6````lastIndexOf()` 方法可返回一个指定的元素在数组中最后出现的位置，从该字符串的后面向前查找。如果要检索的元素没有出现，则该方法返回 `-1````javascriptvar fruits=[&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;,&quot;Mango&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;Apple&quot;];var a = fruits.lastIndexOf(&quot;Apple&quot;,4);//2````includes()` 方法用来判断一个数组是否包含一个指定的值，如果是返回 `true`，否则`false`。`searchElement` 必须参数，需要查找的元素值。`fromIndex` 可选参数，从该索引处开始查找```javascript[1, 2, 3].includes(2);     // true[1, 2, 3].includes(4);     // false[1, 2, 3].includes(3, 3);  // false[1, 2, 3].includes(3, -1); // true[1, 2, NaN].includes(NaN); // true```</code></pre><ul><li><p><code>Array.isArray(obj)</code><br>  isArray() 方法用于判断一个对象是否为数组。如果对象是数组返回 true，否则返回 false。</p><pre><code class="javascript">  Array.isArray([]) ;// true  Arrray.isArray({});//false</code></pre><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>JavaScript数组的有一些特性是其他对象没有的：</p></li><li><p>当有新的元素添加到数组时，自动更新length属性。</p></li><li><p>设置length为一个较小值将截断数组。</p></li><li><p>从Array.prototype 中级证一些有用的方法。</p></li><li><p>其类属性为‘Array’ </p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript学习笔记一</title>
    <link href="/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/28/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>打算把最近学习的JavaScript写个博客整理记录一下，学习方式是《JavaScript语言精粹》这本书和<a href="https://www.liaoxuefeng.com/wiki/1022910821149312" target="_blank" rel="noopener">廖雪峰的博客</a>，不太明白的地方会去看《JavaScript权威指南》、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener">JavaScript|MDN</a>和<a href="https://www.w3school.com.cn/js/index.asp" target="_blank" rel="noopener">W3School</a>。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 变量能够保存多种数据类型：数值、字符串值、数组、对象等等：</p><h3 id="Numbers"><a href="#Numbers" class="headerlink" title="Numbers"></a>Numbers</h3><p>JavaScript只有一种数字类型，不区分整型与浮点型，存储方式使用64位浮点数，1和1.0的值是相同的。</p><pre><code class="javascript">123; // 整数1230.456; // 浮点数0.4561.2345e3; // 科学计数法表示1.2345x1000，等同于1234.5-99; // 负数NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示，可以用isNaN检测NaNInfinity; // Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</code></pre><p>可以操作数字的方法 </p><ul><li>五个number方法 <a href="https://www.w3school.com.cn/js/js_number_methods.asp" target="_blank" rel="noopener">查看</a><ul><li>将数字以字符串返回：<code>number.toString(radix)</code>,<code>radix</code>控制进制，默认十进制。</li><li>将number转换为一个十进制形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）：<code>number.toFixed(fractionDigits)</code></li><li>将number转换成为一个指数形式的字符串，保留<code>fractionDigits</code>位小数（多余的四舍五入）<code>number.toExponential（fractionDigits）</code></li><li>将number转换为一个十进制形式的字符串，保留<code>precision</code>个有效数字（多余的四舍五入）：<code>number.toPrecision(precision)</code></li></ul></li><li>三个全局方法 <a href="https://www.w3school.com.cn/js/js_number_methods.asp" target="_blank" rel="noopener">查看</a><ul><li>可以将x转换为数字，x为任意JavaScript变量（日期，布尔值等）：<code>Number(x)</code></li><li>解析一段字符串并返回整型数值（向下取整）。允许空格。只返回首个数字： <code>parseInt(string)</code></li><li>解析一段字符串并返回数值。允许空格。只返回首个数字：<code>parseFloat(string)</code></li></ul></li><li>math对象方法执行数学数学任务 <a href="https://www.w3school.com.cn/js/js_math.asp" target="_blank" rel="noopener">查看</a><ul><li>返回x的四舍五入：<code>Math.round(x)</code></li><li>返回x的y次幂：<code>Math.pow(x,y)</code></li><li>返回x的平方根：<code>Math.sqrt(x)</code></li><li>返回x的绝对值：<code>Math.abs(x)</code></li><li>x向上取整：<code>Math.ceil(x)</code>，x向下取整：<code>Math.floor(x)</code></li><li>x正弦余弦：<code>Math.sin(x)</code> , <code>Math.cos(x)</code></li><li>最大最小值：<code>Math.min(1,,2,3,4) //1</code> ，<code>Math.max(1,2,3,4) //4</code>,<a href="https://www.cnblogs.com/lguow/p/9725258.html" target="_blank" rel="noopener">用于数组</a></li><li>返回一个0-1的随机数：<code>Math.random()</code>，更多<a href="https://www.w3school.com.cn/js/js_random.asp" target="_blank" rel="noopener">随机数trick</a></li></ul></li></ul><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><p>JavaScript的字符串就是用<code>&#39; &#39;</code>或<code>&quot; &quot;</code>括起来的字符<br>例：</p><pre><code class="javascript">&#39;I\&#39;m \&quot;OK\&quot;!&#39;;</code></pre><p>含义<code>I&#39;m &quot;OK&quot;!</code></p><blockquote><p>字符串一旦创建就不能改变，可以使用字符串方法操作返回新的字符串</p></blockquote><p><code>\</code>是转义字符 </p><pre><code class="javascript">&#39;A&#39; === &#39;\u0041&#39;; //true</code></pre><p>string有<code>length</code>属性</p><pre><code class="javascript">&#39;seven&#39;.length; //5</code></pre><p>可以用<code>+</code>号连接其他字符串来创建一个新的字符串</p><pre><code class="javascript">&#39;c&#39;+&#39;a&#39;+&#39;t&#39; ===&#39;cat&#39;; //true</code></pre><p>string拥有方法 <a href="https://www.w3school.com.cn/js/js_string_methods.asp" target="_blank" rel="noopener">查看</a></p><ul><li><p>查找：<code>string.indexOf(searchString,position)</code> , <code>string.lastIndexOf(seachString,position)</code> , <code>string.search(regexp)</code>.<br><code>searchString</code>要搜索的字符串，<code>position</code>开始搜索的位置，<code>regexp</code>正则表达式对象，以number返回位置</p><blockquote><p> 两种方法，<code>string.indexOf()</code> 与 <code>string.search()</code>，是相等的。</p><p>这两种方法是不相等的。区别在于：</p><p><code>string.search()</code> 方法无法设置第二个开始位置参数。 <code>string.indexOf()</code> 方法无法设置更强大的搜索值（正则表达式）。</p></blockquote></li><li><p>提取字符：<code>string.charAt(position)</code> 方法返回字符串中指定下标（位置）的字符串。<br><code>string.charCodeAt(position)</code>方法返回字符串中指定索引的字符 unicode 编码，常用此方法建造哈希表，相反<code>string.fromCharCode(charCode...)</code>根据编码返回字符串</p><blockquote><p>ECMAScript 5 (2009) 允许对字符串的属性访问 <code>[ ]</code>，如<code>str[0]</code><br>用属性访问有点不太靠谱：</p><p>不适用 Internet Explorer 7 或更早的版本 它让字符串看起来像是数组（其实并不    是） 如果找不到字符，<code>[ ]</code> 返回 <code>undefined</code>，而 <code>charAt()</code> 返回空字符串。<br>它是只读的。<code>str[0] = &quot;A&quot;</code> 不会产生错误（但也不会工作！）<br>如果您希望按照数组的方式处理字符串，可以先把它转换为数组。</p></blockquote></li><li><p>把字符串转换为数组：<code>string.split(separator,limit)</code><br>以<code>separator</code>分割，改参数可以是字符串或正则表达式，<code>limit</code>限制被分割的片段数量，返回元素为字符串的数组。</p></li><li><p>提取字符串：<code>string.slice(start, end)</code>，<code>string.substring(start, end)</code>，<code>string.substr(start, length)</code><br><code>start</code><strong>开始</strong>提取位置，<code>end</code><strong>最后</strong>一个字符的位置，如果为负数则与<code>string.length</code>相加，即倒数位置，<code>length</code>要提取的字符串<strong>长度</strong>。<br>不改变原字符串，将提取结果以新字符串返回。</p><blockquote><p><code>substring()</code> 类似于 <code>slice()</code>。不同之处在于 <code>substring()</code> 无法接受负的索引。<br><code>substr()</code> 类似于 <code>slice()</code>。不同之处在于第二个参数规定被提取部分的长度。</p></blockquote></li><li><p>替换：<code>replace(seachValue,replaceValue)</code><br><code>seachValue</code>可以是<strong>字符串</strong>或<strong>正则表达式</strong>，<code>replaceValue</code>可以是<strong>字符串</strong>或一个<strong>函数</strong>。<br>当<code>replaceValue</code>是一个<strong>字符串</strong>，字符<code>$</code>拥有特别含义：</p><pre><code class="javascript">  var oldareacode = /\((\d{3})\)/g;  var p = &#39;(555)666-1212&#39;.replace(oldareacode,&#39;$1-&#39;);  //p 是 &#39;555-666-1212&#39;</code></pre><table><thead><tr><th>美元符号序列</th><th>替换对象</th></tr></thead><tbody><tr><td>$<code>$$</code></td><td>$</td></tr><tr><td>$<code>$&amp;</code></td><td>整个匹配文本</td></tr><tr><td>$<code>$number</code></td><td>分组捕获的文本</td></tr><tr><td>$<code>$`</code></td><td>匹配之前的文本</td></tr><tr><td>$<code>$&#39;</code></td><td>匹配之后的文本</td></tr></tbody></table><p>  如果<code>replaceValue</code>是一个<strong>函数</strong>，那么每次遇到一次匹配函数就会调用一次，该函数返回的字符串用作替换文本，在下一个参数是分组2捕获的文本、</p></li></ul><pre><code>```javascriptvar old = &#39;hello World&#39;;var p = old.replace(&#39;hello&#39;,function (c){    console.log(c);//hello    return &#39;Hello&#39;        })console.log(p);//Hello World```&gt;`replace()` 只替换首个匹配&gt;默认地，`replace()` 对大小写敏感。&gt;如需执行大小写不敏感的替换，请使用正则表达式 `/i`,请注意正则表达式不带引号。如：`replace(/he/i,&#39;she&#39;)`&gt;如需替换所有匹配，请使用正则表达式的 `/g` 标志（用于全局搜索)。如：`replace(/he/g,&#39;she&#39;)`</code></pre><ul><li>转换大小写：<code>toUpperCase()</code>,<code>toLowerCase()</code></li><li>连接字符串：<code>concat()</code>与<code>+</code>等效</li><li>删除字符串两端的空白符：<code>String.trim()</code><blockquote><p>Internet Explorer 8 或更低版本不支持 <code>trim()</code> 方法。<br>如需支持 IE 8，您可搭配正则表达式使用 <code>replace()</code> 方法代替：<br><code>str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#39;&#39;)</code>; </p></blockquote></li><li>匹配：<code>string.match(regexp)</code>方法让字符串与一个正则表达式匹配。根据g表示来决定如何匹配，如果没有<code>g</code>表示，那么结果与<code>regexp.exec(string)</code>的结果相同。否则会生成包含所有匹配的数组。</li></ul><h4 id="多行字符串和模板字符串"><a href="#多行字符串和模板字符串" class="headerlink" title="多行字符串和模板字符串"></a>多行字符串和模板字符串</h4><p>ES6语法</p><pre><code class="javascript">`这是一个多行字符串`;</code></pre><pre><code class="javascript">var name = &#39;小明&#39;;var age = 20;var message = `你好, ${name}, 你今年${age}岁了!`;message === &#39;你好,小明,你今年20岁了&#39;; //true</code></pre><h3 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h3><p>布尔值只有<code>true</code>和<code>false</code></p><pre><code class="javascript">true; // 这是一个true值false; // 这是一个false值2 &gt; 1; // 这是一个true值2 &gt;= 3; // 这是一个false值</code></pre><p>几个tips</p><ul><li><code>NaN</code>这个特殊的Number与所有其他值都不相等，包括它自己<pre><code class="javascript">NaN === NaN; // false</code></pre></li><li>唯一能判断<code>NaN</code>的方法是通过<code>isNaN()</code>函数：</li></ul><pre><code class="javascript">isNaN(NaN); // true</code></pre><ul><li>最后要注意浮点数的相等比较：</li></ul><pre><code class="javascript">1 / 3 === (1 - 2 / 3); // false</code></pre><blockquote><p>这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p></blockquote><pre><code class="javascript">Math.abs(1 / 3 - (1 - 2 / 3)) &lt; 0.0000001; // true</code></pre><h3 id="null和undefined"><a href="#null和undefined" class="headerlink" title="null和undefined"></a>null和undefined</h3><p><code>null</code>表示一个“空”的值<br><code>undefined</code>表示值未定义</p><blockquote><p>JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。</p><pre><code class="javascript">var misc = [1, 2, 3.14, &#39;Hello&#39;, null, true，[&#39;&#39;,&#39;&#39;],{&#39;&#39;:&#39;&#39;}];misc.length  //8misc[0] //1misc[8] //undefined</code></pre><p>与大多数其他语言不同，JavaScript的数组没有上界</p><pre><code class="javascript">var myArray = [1,2,3,4,5];myArray.length; // 5myArray[10000] = true;myArray.length; //10001myArray.length = 3;//myArray是[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;]</code></pre><p>数组专题<br>数组拥有方法 <a href="https://www.w3school.com.cn/js/js_array_methods.asp" target="_blank" rel="noopener">查看</a><br>数组的排序 <a href="https://www.w3school.com.cn/js/js_array_sort.asp" target="_blank" rel="noopener">查看</a><br> 数组的遍历 <a href="https://www.w3school.com.cn/js/js_array_iteration.asp" target="_blank" rel="noopener">查看</a></p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p><pre><code class="javascript">var person = {    name: &#39;Bob&#39;,    age: 20,    tags: [&#39;js&#39;, &#39;web&#39;, &#39;mobile&#39;],    city: &#39;Beijing&#39;,    hasCar: true,    zipcode: null};</code></pre>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
